@    using System.Diagnostics
@    using System.Text;
@inject IStringLocalizer<Resource> Localize
@inject IJSRuntime js
@inject AppState AppState
@implements IDisposable

<canvas hidden id="canvas"/>
<MudList Clickable="false" Dense="true" DisablePadding="true" Style="width:100%" Class="d-flex flex-column pa-0">
	<MudListItem Class="pb-2 pt-3">
		<ProgressBar Task="@processingTask" ProgressValue="@processingValue"/>
	</MudListItem>
	<MudListItem Class="pt-0">
		<MudList Clickable="false" DisableGutters="true" DisablePadding="true" Dense="true" Style="width:100%" Class="d-flex justify-space-around flex-row">
			<MudButton  
				HtmlTag="label"
				Variant="Variant.Filled"
				Color="Color.Primary"
				StartIcon="@Icons.Filled.UploadFile"
				OnClick="Encode"
				Disabled=@(!CanEncode)
				Style="width:100%">
				<MudText Typo="Typo.button" Class="align-center">@Localize["Encode"]</MudText>
			</MudButton>
			<MudDivider Vertical="true" FlexItem="true" DividerType="DividerType.Middle"/>
			<SaveButton fileToSave="@encodedCarrier"/>
		</MudList>
	</MudListItem>
</MudList>

<div>@time2.ToString()</div>
<div><br />@time3.ToString()</div>
@code {
	[Parameter] public bool CanEncode { get; set; } = false;

	[Parameter] public Image? Carrier { get; set; }

	[Parameter] public Message? Message { get; set; }

	[Parameter] public ImageOptions? Options { get; set; }

	[Parameter] public EventCallback<bool> OnProcessingChanged { get; set; }

	[Parameter] public EventCallback<File> OnEncodedCarrierChanged { get; set; }

	File? encodedCarrier;

	int processingValue = 0;
	string? processingTask = "";

	Stopwatch watch = new Stopwatch();

	Stopwatch watch2 = new Stopwatch();
	Stopwatch watch3 = new Stopwatch();
	double time2 = 0;
	double time3 = 0;

	protected override void OnInitialized() { AppState.OnChange += StateHasChanged; }
	public void Dispose() { AppState.OnChange -= StateHasChanged; }

	async Task UpdateProgress(string progressBarText, int progressBarValue)
	{
		processingTask = progressBarText;
		processingValue = progressBarValue;
		StateHasChanged();
		await Task.Delay(10);
	}

	async Task Encode()
	{
		if (Carrier is null || Message is null || Options is null)
			throw new Exception();

		watch.Reset();
		watch.Start();

		await OnProcessingChanged.InvokeAsync(true);
		encodedCarrier = null;

		await UpdateProgress(Localize["ReadingImageData"], 0);
		Carrier.pixelData = await JSInterop.ReadStream(js, "getImageData");

		if (Options.password is not null)
		{
			try
			{
				await UpdateProgress(Localize["EncryptingMessage"], 20);
				await EncryptMessage();
			}
			catch
			{
				await UpdateProgress(Localize["ErrorEncryptingMessage"], 0);
				return;
			}
		}

		try
		{
			PixelParams sampleParams = new PixelParams(Options.scatteredEncodingEnabled ? PixelOrder.Random : PixelOrder.Sequential, Options.bitsToEncode);
			ImageEncoder encoder = new ImageEncoder(Carrier, sampleParams);
			var encodedCarrierBytes = await EncodeFile(encoder);

			await UpdateProgress(Localize["SavingImageData"], 80);

			string encodedCarrierURL = ((IJSInProcessRuntime)js).Invoke<string>("getImageURL", encodedCarrierBytes, (Options?.webPFormatEnabled ?? false) ? "image/webp" : "image/png");

			encodedCarrier = new File { base64Data = encodedCarrierURL.Split(";", 2)[1].Substring(7), 
										contentType = encodedCarrierURL.Split(";", 2)[0].Substring(5),
										fileName = AddSuffix(Carrier.fileName) };
		}
		catch
		{
			await UpdateProgress(Localize["ErrorEncodingMessage"], 0);
			return;
		}

		watch.Stop();
		await UpdateProgress(Localize["EncodingDoneIn"] + " " + watch.Elapsed.TotalSeconds.ToString("0.00") + " s!", 100);

		await OnProcessingChanged.InvokeAsync(false);
		await OnEncodedCarrierChanged.InvokeAsync(encodedCarrier);
	}
	async Task<byte[]> EncodeFile(ImageEncoder encoder)
	{
		if (Message is null)
			throw new Exception();

		await UpdateProgress(Localize["EncodingMessage"], 30);

		encoder.Encode(Message.header);

		int updates = Message.fileData.Length / 250000 + 1;
		int updatesDone = 0;
		int bytesLeft = Message.fileData.Length;

		while (bytesLeft > 250000)
		{
			encoder.Encode(Message.fileData[(250000 * updatesDone)..(250000 * (updatesDone + 1))]);
			updatesDone++;
			bytesLeft -= 250000;
			await UpdateProgress(Localize["EncodingMessage"], 25 + updatesDone * 50 / updates);
		}

		encoder.Encode(Message.fileData[(250000 * updatesDone)..]);

		return encoder.GetEncodedCarrier();
	}
	async Task EncryptMessage()
	{
		if (Message is null || Options?.password is null)
			return;

		byte[] passwordBytes = Encoding.UTF8.GetBytes(Options.password);
		byte[] salt = System.Security.Cryptography.RandomNumberGenerator.GetBytes(16);
		byte[] ivHeader = System.Security.Cryptography.RandomNumberGenerator.GetBytes(12);
		byte[] ivFile = System.Security.Cryptography.RandomNumberGenerator.GetBytes(12);

		List<byte[]> aesInputs = new List<byte[]> { Message.fileData, passwordBytes, salt, ivFile };
		Message.fileData = await JSInterop.ReadStream(js, "encryptData", aesInputs);
		Message.UpdateHeader();

		aesInputs = new List<byte[]> { Message.GenerateMetadata(), passwordBytes, salt, ivHeader };
		Message.UpdateHeader(await JSInterop.ReadStream(js, "encryptData", aesInputs), salt.Concat(ivHeader).Concat(ivFile).ToList());
	}
	string AddSuffix(string fileName)
	{
		string name = Path.GetFileNameWithoutExtension(fileName);
		return (Options?.webPFormatEnabled ?? false) ? String.Concat(name, Localize["_encoded"], ".webp") : String.Concat(name, Localize["_encoded"], ".png");
	}
}
